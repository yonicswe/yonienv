[user]
	author = Yonatan Cohen
	name = yonatan.cohen
	email = yonatan.cohen@dell.com

# accepted values are two of
# normal, black, red, green, yellow, blue, magenta, cyan, white
# and optionally one of
# bold, dim, ul, blink and reverse
[color]
	status = auto
	branch = auto
	diff = auto

[color "grep"]
    linenumber = yellow bold
    match = red
    filename = magenta

[color "diff"]
  meta = yellow
  frag = magenta bold
  old = red
  new = green
  whitespace = magenta reverse

[color "status"]
  added = yellow
  changed = red
  untracked = cyan

[alias]


# ───────a──────────────────────────────────────────────────────────────────────
#   print the alias implementation
#   git config --get-regexp alias.<alias name>	

    alias = ! git config --get-regexp ^alias\\. | sed -e s/^alias\\.// -e s/\\ /\\ =\\ /

    amendsources= commit --amend --no-edit -n
#     amend = commit --amend --reuse-message=HEAD
    amendcommitlog = commit -n --amend
    amendauthor = commit --amend --author='yonatan cohen <yonatan.cohen@dell.com>'
    amenddatenow = git commit --amend --no-edit --date "$(date)"
    amrej = am --reject

    a = add
    au = add -u
    ae = add -e
    ap = add -p
#   a = "!f() {                \
#	   if [ -z $1 ] ; then \
#             git add -u ;     \
#          else                \
#             git add $1 ;     \
#          fi;                 \
#          }; f"	   

# ───────b──────────────────────────────────────────────────────────────────────

    b = branch
    bt = branch -vv
    ba = branch -a
    br = branch -r
    bdelete = branch -D 
    brename = branch -M
    byoni = ba --list "*ycohen*"

#   if branch name is posixed with v<number> 
#   increment the version v<number++>
    branchincversion = "!f() { \
       newversion=$1;\
       v=$(git bb |grep -E -o "v[0-9]+$"); \
       b=$(git bb | sed 's/-v.*//g'); \
       if [ $# -eq 1 ] ; then \
          git cb $(git bb)-v${newversion}; \
          return;\
       fi;\
          \
       if [ -z $v ] ; then \
          bnewname=$(git bb)-v1; \
          if [ $(git b |grep ${bnewname} | wc -l) -eq 0 ] ; then \
             git cb ${bnewname}; \
          else \
             echo 'branch already exists'; \
             git b | grep ${b}; \
          fi;\
       else \
          v=$(echo $v | grep -E -o "[0-9]"); \
          bnewname=$(git bb | sed 's/v[0-9]//'); \
          v=$((v + 1)) ;\
          bnewname=${bnewname}v$v; \
          if [ $(git b |grep ${bnewname} | wc -l) -eq 0 ] ; then \
             git cb ${bnewname}; \
          else \
             echo 'branch already exists.'; \
             git b | grep ${b}; \
          fi;\
       fi; \
    };f "

#   print the name of the currently checked branch
    bb = rev-parse --abbrev-ref HEAD



    edit = "!f() {                  \
  	   if [ $# -eq 0 ] ; then   \
              git commit --amend ;  \
	   else                     \
	      GIT_EDITOR=~/yonienv/bin/gitedit.sh git rebase -i $1^; \
           fi                       \
    }; f"
    e = edit


    listmodified = diff --name-only
    listcached = diff --cached --name-only
#   listtrackedfiles = ls-tree --name-only -r 
    listtrackedfiles = "!git ls-files"
    listtags = tag -l

    mt = mergetool
    mtv = mergetool --tool=vimdiff



# ───────c──────────────────────────────────────────────────────────────────────
    commitempty = commit --allow-empty
    c = checkout
    cb = checkout -b
#   cmn = checkout master_next
    commitfilelist = show --stat --oneline
    checkoutmaster = "!f() { \
	git fetch origin master; \
	git checkout -b master FETCH_HEAD; \
    }; f"

    checkoutremotefilefromremotebranch = "!f() { \
        branch=$1; \
        file=$2; \
        if [ -z $file ] || [ -z $branch ] ; then \
             echo 'gitcheckoutremotebranch <branch> <path-to-file/file>'; \
             return; \
        fi; \
        git checkout origin/$branch -- $file; \
        git s; \
       }; f"

#   checkoutbranchfrommasternext = "!f() {                       \
#     if [ -n $1 ] ; then		                         \
#   	git fetch origin master_next;                    \
#   	git cb dev/ycohen/sw-$1 FETCH_HEAD;              \
#   	git branch --set-upstream-to=origin/master_next; \
#   	git pull --rebase;                               \
#     fi;                                                    \
#   }; f"


#   cherry-pick-commit = "!f() {              \
#       if [ $# -gt 0 ] ; then                 \
#          git cherry-pick $1^..$1 ;          \
#       fi;                                  \
#   }; f"

    cleanuntracked = "!f() { git ls-files --others | xargs rm --interactive=once;}; f"

# ───────d──────────────────────────────────────────────────────────────────────
    dg = "!f() {					     \
	  if [ -z $1 ] ; then				     \
		git difftool --tool=gvimdiff;		     \
	  else						     \
		git difftool --tool=gvimdiff --no-prompt $1; \
	  fi;                                                \
	}; f"

    deleteremotebranch = "!f()  {             \
	  echo delete branch on the remote;   \
	  echo :      git push -d remote branch;     \
	  echo : e.g. git push -d origin $(git bb);     \
                                              \
	  echo other checkedout repo from this remote need to run; \
	  echo :   git fetch -p ;\
	  }; f" 

    d = diff
    dw = diff --ws-error-highlight=all
    dfile = difftool --no-prompt
    dt = difftool
    dc = diff --cached
    dtc = difftool  --cached
    ds = diff --stat


    # discardall = checkout HEAD -- .
    discard = "!f() {              \
       if [ -z $1 ] ; then         \
          git checkout HEAD -- . ; \
       else                        \
          git checkout $1 ;        \
       fi;                         \
    }; f" 


    diffnameonly = "!f() { git show $1 |diffstat -p1 -l; }; f"


    # diffcommit = "!f() { git difftool $1^..$1 --tool=gvimdiff; }; f"
    diffcommit =  "!f() {                                   \
      if [ -z $1 ] ; then                                   \
         git difftool HEAD^..HEAD --prompt; \
      else                                                  \
         git difftool $1^..$1 --prompt;     \
      fi ;                                                  \
    }; f"

    diffcommitfile = "!f() {                                \
	if [ $# -eq 1 ] ; then                              \
	   git difftool HEAD^..HEAD  -y $1 ; \
	else                                                \
    	   git difftool $1^..$1  -y $2;      \
	fi;                                                 \
    }; f"

    difffilebetweenbranches = "!f() {  \
	branchA=$1; \
	branchB=$2; \
	file=$3; \
	if [ $# -eq 0 ] ; then \
		echo 'difffilebetweenbranches <branch> <branch> <file>'; \
		return; \
	fi; \
	git dt $branchA $branchB -- $file; \
    }; f"

# ───────f──────────────────────────────────────────────────────────────────────
    format-patch-commit = "!f() {              \
	if [ $# -eq 0 ] ; then                 \
	   git format-patch HEAD^..HEAD ;      \
	else                                   \
	   git format-patch $1^..$1 ;          \
        fi;                                  \
    }; f"

    find-commit-in-branch = "!f() {   \
	c=$1;                         \
	if [ -z $c ] ; then           \
		echo 'usage find-commit-in-branch <commit>'; \
	else                          \
		git log |grep --color $c;     \
	fi;                           \
	}; f"

    find-file = "!f() { c=$1; if [ -z $c ] ; then return ; fi ;  git ls-files | grep --color $c; }; f"

# ───────g──────────────────────────────────────────────────────────────────────
    gl = log --graph --full-history --all --color --pretty=format:%x1b[31m%h%x09%x1b[32m%d%x1b[0m%x20%s
    gls = log --graph --full-history --all --color --pretty=format:%x1b[31m%h%x09%x1b[32m%d%x1b[0m%x20%s --simplify-by-decoration
    g = grep --color -n
    gi = grep --color -n --ignore-case

    gog = log  --abbrev-commit --name-status --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'

# ───────h──────────────────────────────────────────────────────────────────────
#   h = log -n1 --pretty=oneline
        h = "!f() { if [ -e .git ] ; then\
                       if [ -d .git ] ; then\
                          cat .git/refs/heads/$(git bb);\
                          echo '------------------------------------';\
                       elif [ -f .git ] ; then\
                          echo "$(cat $(cat .git | cut -d ' ' -f 2 )/refs/heads/$(git bb))";\
                          echo '------------------------------------';\
                       fi;\
                    fi;\
                    git logstat -1;}; f"

# ───────i──────────────────────────────────────────────────────────────────────
    info = logstat -1 --pretty=fuller

# ───────l──────────────────────────────────────────────────────────────────────
#                                   SHA          date                   name             msg
    ls = log --pretty=format:'%C(yellow) %h %Cred%<(9,trunc)%aN %Cgreen%s %Creset' 
    ll = ls -10
#   lll = log --pretty=format:'%C(yellow)%h %Cred%ad %>(10,trunc) %Cblue%an%Cgreen%d %Creset%s'
    lll = log --pretty=format:'%C(yellow)%h %Cred%cd %>(10,trunc) %Cblue%an%Cgreen%d %Creset%s ' --date=short
#   lf = log --pretty=short
#   ll = log --pretty=format:'%C(yellow)%h %Cred%cd %C(magenta)[author %ad] %Cblue%an%Cgreen%d %Creset%s' --date=short
#   l = "!f() { n=${1:-200}; git log --pretty=format:'%C(yellow)%h %Cred%cd %>(10,trunc) %Cblue%an%Cgreen%d %Creset%s' --date=short ${count} -$n; }; f"
    lyoni = log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s' --date=short --author='yonatan.cohen'
#   l10 = log --pretty=format:'%C(yellow)%h %Cred%ad %>(10,trunc) %Cblue%an%Cgreen%d %Creset%s ' --date=short -n10
#   l20 = log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s ' --date=short -n20
#   l30 = log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s ' --date=short -n30

    logfilehistory = whatchanged --pretty=format:'%C(yellow)%h %Cred%ad %>(10,trunc) %Cblue%an%Cgreen%d %Creset%s' --date=short
#   also can track  changes to file with tig -- <file>

    lnameonly = log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate --numstat
    logstat = log --stat

    # list only untracked files
    lu = ls-files --others
    lgraph = !git lg1
    lg1 = !git lg1-specific --all
    lg2 = !git lg2-specific --all
    lg3 = !git lg3-specific --all

    lg1-specific = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim red)- %an%C(reset)%C(yellow)%d%C(reset)'
    lg2-specific = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' %C(white)%s%C(reset) %C(dim white)- %an%C(reset)'
    lg3-specific = log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset) %C(bold cyan)(committed: %cD)%C(reset) %C(bold yellow)%d%C(reset)%n'' %C(white)%s%C(reset)%n'' %C(dim white)- %an <%ae> %C(reset) %C(dim white)(committer: %cn <%ce>)%C(reset)'

    list-author = "!f() { git log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s' --date=short --author="$1"; }; f"

# ───────p──────────────────────────────────────────────────────────────────────
#   push-commit = "!f() {                 \
#	   if [ -z $1 ] ; then            \
#             git push origin HEAD:master;\
#          else                           \
#             git push orign $1:master;   \
#          fi;                            \
#          }; f"
#

    pushthisbranchtoremote = "!f() {                               \
                remote=${1:-origin};                               \
                git push -u ${remote} $(git rev-parse --abbrev-ref HEAD); \
                }; f"

    pushthisbranchtoremotewithforce = "!f() {                                 \
                remote=${1:-origin};                               \
                git push --force ${remote} $(git rev-parse --abbrev-ref HEAD); \
                }; f"


    gc=gc --auto --aggressive


    pushlist = "!f() { \
            if [ $# -gt 0 ] ; then  \
            echo git diff --stat --cached $1/$2 ; \
            git diff --stat --cached $1/$2 ; \
            else \
            echo git diff --stat --cached origin/master ; \
            git diff --stat --cached origin/master ; \
            fi; \
            }; f"




# ───────r──────────────────────────────────────────────────────────────────────
    reusecommit = "!f() { git commit -n --reuse-message=$(cat reuse_commit.txt); }; f"


    r = remote -vv

    rebaseback = "!f() { if [[ $# -eq 0 ]] ; then  \
                            echo 'git rebasebackto <number of commits>' ;\
                            return ; \
                         fi; \
                         git rebase -i HEAD~$1; }; f"

    rlog = log --show-notes=review
    rebaseto = "!f() { if [[ $# -eq 0 ]] ; then  \
                          echo 'git rebaseto <commit id>' ;\
                          return ; \
                       fi; \
                       git rebase -i $1^; }; f"



# ───────s──────────────────────────────────────────────────────────────────────
    s = "!f() { git tt ;  git status -uno; }; f"
    
    su = status -u
    ss = show --stat

    saveheadindex = "!f() { \
		   git log -n1 --pretty=oneline | cut -d ' ' -f1 > reuse_commit.txt; \
		   echo "saved head index $(cat reuse_commit.txt) to reuse_commit.txt" ; \
		   echo "git reusecommit to get it back" ; \
    		}; f"

    syncbranches = fetch -p

    # showuser = "!f() { me=${1-:*} ; git config --get-regex alias.* | sed 's/alias\.//g' | grep -w --color $me;}; f"
    showuser = "!f() { me=${1-:*} ; git config --get-regex alias.$me | grep --color $me;}; f"

    sm = submodule
    smdiff = diff --submodule
    smgrep = grep --recurse-submodules
    smupdate = submodule update
    smupdateinit = submodule update --init
    smstatus = sm foreach
#   smstatus = "!f()  { git sm status | awk '{if (NF > 2) {print $2 " " $3} }' | column -t; }; f"
    smremove = submodule deinit
#
#   sm-resetall = submodule foreach --recursive git reset --hard; 
    sm-resetall = "!f() {\
        for s in source/* ; do\
           echo "$s reset modified content";\
           cd $s ; git c . ;\
           cd - ;\
           echo "$s reset new commits";\
           git smupdate $s;\
        done; }; f"

    sm-update-all = submodule update --recursive
    sm-updateinit-all = submodule update --init --recursive
#   cleanuntracked = clean -df	

#     branch-upstream-kernel-rdma-next-mlx = "!f() { git fetch origin rdma-next-mlx ; git c -b $1@rdma-next-mlx FETCH_HEAD ; }; f"
#     rebase-upstream-kernel-rdma-next-mlx = "!f() { git fetch origin rdma-next-mlx ; git rebase FETCH_HEAD ; }; f"
#     branch-rdmacore-for-upsteam = "!f() { git fetch origin for-upstream ; git c -b $1@for-upstream FETCH_HEAD ; }; f"
#     rebase-rdmacore-for-upsteam = "!f() { git fetch origin for-upstream ; git rebase FETCH_HEAD ; }; f"
#     branch-ofa-kernel-4-6 = "!f() { if [ -z $1 ] ; then return ; fi;  git fetch origin mlnx_ofed_4_6 ; git c -b $1@mlnx_ofed_4_6 FETCH_HEAD ; }; f"
#     rebase-ofa-kernel-4-6 = "!f() { git fetch origin mlnx_ofed_4_6 ; git rebase FETCH_HEAD ; }; f"


# ───────t──────────────────────────────────────────────────────────────────────
    trackbranch = "!f() { git branch --set-upstream-to=origin/$(git bb); \
		   echo tracking ; git t; }; f"
    tb = trackbranch
    track = rev-parse --abbrev-ref --symbolic-full-name @{u}
    t = track 
    tt = status -uno -sb
#   trackmaster = branch --set-upstream-to=origin/master
#   trackmasternext = branch --set-upstream-to=origin/master_next
#   tm = trackmaster
#   tmn = trackmasternext

# ───────u──────────────────────────────────────────────────────────────────────

    untrack = branch --unset-upstream
    unstage = reset HEAD
    # uncommit = reset HEAD^

    uncommit = "!f() { git saveheadindex ; git reset HEAD^ ; }; f"

    untrackfile = rm --cached 

    savework = "!f() { \
	    git commit -a -n -m 'save work'; \
    }; f"
    sl = stash list
[core]
	editor = vim

[diff]
	# tool = nvimdiff
	tool = vimdiff

# [difftool "nvimdiff"]
	# cmd = "nvim -d \"$LOCAL\" \"$REMOTE\""
	# prompt = true
[difftool]
	prompt = true

[merge]
# 	tool = nvimdiff
 	tool = vimdiff

# [mergetool "nvimdiff"]
  # cmd = nvim -d \"$LOCAL\" \"$MERGED\" \"$BASE\" \"$REMOTE\" -c \"wincmd w\" -c \"wincmd J\"

[commit]
# template = ~/share/yonienv/git_commit_template

[credential]
	helper = cache

[push]
	default = simple
[core]
	whitespace = trailing-space,space-before-tab,indent-with-non-tab
[gc]
	autoDetach = false
[grep]	
	linenumber = true


[sendemail]
#       smtpserver = /usr/local/bin/msmtp-enqueue.sh
	suppresscc = self
	signedoffbycc = true
	cccover = true
	tocover = true
	chainReplyTo = false
	confirm = always
	from = Yonatan Cohen <yonatanc@mellanox.com>
	envelopeSender = Yonatan Cohen <yonatanc@mellanox.com>
	signingkey = yonatanc@mellanox.com
[gpg]
	program = gpg2




# 
#  all sorts of aliases.
#
#   commityoni = "!f() { \
#		    git config commit.template ~/share/yonienv/git_commit_template_yonic; \
#		    git commit; \
#		  }f"
#   commitmlx = "!f() { \
# 		    git config commit.template ~/share/yonienv/git_commit_template; \
# 		    git commit; \
#		  }f"
#
#   l = log --pretty=format oneline
#   l10 = log --pretty=oneline -n10
#   l30 = log --pretty=oneline -n30
# ll = log --pretty=oneline --graph --decorate --abbrev-commit
# ll = log --graph --decorate --pretty=format:"%h %an, %ar - %s"
#    ll =   log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s' --date=short
#
# diffcommitfile = "!f() { git difftool $1^..$1 --tool=gvimdiff $2;}; f"
#
#
#
#
#   l =  "!f() {                             \
#     if [ -z $1 ] ; then                             \
#        git log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s' --date=short;  \
#     else                                            \
#        git log -n $1 --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s' --date=short;  \
#     fi ;                                            \
#   }; f"
#   
#
# lyoni = log --pretty=oneline --date=short --author='Yonatan Cohen'
#
#   ls = log --pretty=format:"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]" --decorate 
#   ls = log --pretty=format:'%C(yellow)%h %Cred%ad %Cblue%an%Cgreen%d %Creset%s' --date=short
[pull]
	rebase = true
[http]
	postBuffer = 524288000
[credential]
	helper = cache
[tig "bind"]
    generic = D !git dt --no-prompt %(commit)^ %(commit)
    main = w !git difftool  %(commit)^!
    diff = w !git difftool --tool=vimdiff  %(commit)^!
#   main = = !git commit --fixup=%(commit)
#   main = <ctrl-r> !git rebase --autosquash -i %(commit)

[tig]
#   main-view-date = custom
#   main-view-date-format = "%Y-%m-%d-%H:%M"
#   main-view-date-display = relative-compact
#   main-view-commit-title-graph = v1
    main-view-author-display = abbreviated
    main-view-id-display = yes
    vertical-split = yes
    mouse = yes
    blame-view-line-number = yes

[fetch]
    recurseSubmodules = false
[pull]
    recurseSubmodules = false
[update]
    recurseSubmodules = false

# tips
# find out if a commit is part of this cherkcout.
# git log | grep <commit id>
#
# find out on which branches a commit id is on
# git branch --contains <commit id>
#
# how to git pull only one file ? 
#    git fetch
#    git checkout <remote>/<branch -- <path-to-file/filename>
#    now that file will appear as staged.
#    you can commit it here but its original  commit will not show in the logs.
